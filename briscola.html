<!DOCTYPE html>
<html>
<head>

<style>
html {
    margin: 0 auto;
    max-width: 600px;
    background-color: honeydew;
}
#opponent_hand, #player_hand, #table {
    display: flex;
    align-items: center;
}
#table {
    height: 20em;
    justify-content: center;
}
.opponent_card {
    height: 16em;
    width: 7em;
    margin: 2em;
    border-radius: 1em;
    background-color: aliceblue;
    font-size: 2ex;
}
.card_down {
    height: 16em;
    width: 7em;
    margin: 1em;
    border-radius: 1em;
    background-color: linen;
    font-size: 2ex;
    visibility: hidden;
}
.trump_card {
    height: 7em;
    width: 16em;
    margin: 2em;
    border-radius: 1em;
    background-color: linen;
    font-size: 2ex;
}
.player_card {
    height: 16em;
    width: 7em;
    margin: 2em;
    border-radius: 1em;
    background-color: linen;
    font-size: 2ex;
}
.player_card:hover {
    background-color: salmon;
}
</style>

<!-- Script section with common game utilities.
     The actual game loop is at the bottom of
     the page.
-->
<script>
"use strict";

function shuffle(array) {
  let currentIndex = array.length;

  // While there remain elements to shuffle...
  while (currentIndex != 0) {

    // Pick a remaining element...
    let randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex--;

    // And swap it with the current element.
    [array[currentIndex], array[randomIndex]] = [
      array[randomIndex], array[currentIndex]];
  }
}

// Cards will be represented as a three-char string:
// "Value Suit" where
// Value: 1, 2, 3, 4, 5, 6, 7, F, C, R
// Suit: B C D S
// B has values [1..10]
// C has values [11..20]
// D has values [21..30]
// S has values [31..40]
function cardToNumber(text) {
    const ts = text.split(' ');
    let n = Number();
    switch(ts.at(0)) {
        case 'F':
            n = 8;
            break;
        case 'C':
            n = 9;
            break;
        case 'R':
            n = 10;
            break;
        default:
            n = Number(ts.at(0));
            break;
    }
    switch (ts.at(1)) {
        case 'B':
            break;
        case 'C':
            n += 10;
            break;
        case 'D':
            n += 20;
            break;
        case 'S':
            n += 30;
            break;
    }
    return n;
}

const value = (n) => ((n - 1) % 10) + 1;
const suit = (n) => Math.floor((n - 1) / 10);

// Returns the value in points of a number 1...10
// where 1 is the ace and 10 is the king.
const pvalue = {};
pvalue[1]  = 11;
pvalue[3]  = 10;
pvalue[10] = 4;
pvalue[9]  = 3;
pvalue[8]  = 2;
pvalue[7]  = 0;
pvalue[6]  = 0;
pvalue[5]  = 0;
pvalue[4]  = 0;
pvalue[2]  = 0;


// Returns the strength of a number 1...10
// where 1 is the ace and 10 is the king.
const svalue = {};
svalue[1]  = 10;
svalue[3]  = 9;
svalue[10] = 8;
svalue[9]  = 7;
svalue[8]  = 6;
svalue[7]  = 5;
svalue[6]  = 4;
svalue[5]  = 3;
svalue[4]  = 2;
svalue[2]  = 1;

function numberToCard(n) {
    const val = value(n);
    let s = String();
    if (val < 8) {
        s = String(val);
    } else if (val === 8) {
        s = 'F';
    } else if (val === 9) {
        s = 'C';
    } else if (val === 10) {
        s = 'R';
    }
    s += ' ';
    switch (suit(n)) {
        case 0:
            s += 'B';
            break;
        case 1:
            s += 'C';
            break;
        case 2:
            s += 'D';
            break;
        case 3:
            s += 'S';
            break;
    }
    return s;
}

// Computes the points assigned by the hand where the
// first player plays c0 and the second player plays c1.
// Returns the number of points won by the winning player,
// and the identity of the winning player (0 or 1).
function computeHand(c0, c1, trump_suit) {
    const v0 = value(c0);
    const v1 = value(c1);
    const s0 = suit(c0);
    const s1 = suit(c1);
    const pts = pvalue[v0] + pvalue[v1];
    // wins is 0 if player 0 wins, 1 if player 1 wins.
    let wins = 0;
    if (s0 === trump_suit) {
        if (s1 === trump_suit) {
            wins = Number(svalue[v0] < svalue[v1]);
        }
        // else player 0 wins.
    } else if (s1 === trump_suit) {
        // Player 1 wins
        wins = 1;
    } else if (s0 === s1) {
        wins = Number(svalue[v0] < svalue[v1]);
    } // else player 0 wins.
    return [pts, wins];
}

const sleep = (ms) => new Promise(res => setTimeout(res, ms));

// Class to encapsulate the state of the game.
class GameState {
    constructor() {
        // Deck is [1..40]
        this.deck = Array(40).fill().map((_, i) => i + 1);
        shuffle(this.deck);

        // Initial draw.
        this.hands[0] = [this.deck.pop(), this.deck.pop(), this.deck.pop()];
        this.hands[1] = [this.deck.pop(), this.deck.pop(), this.deck.pop()];
        this.trump_suit = suit(this.deck.at(0));
        // True if player 0 won last hand.
        this.won_last = true;
        this.points = [0, 0];
    }

    // Current cards in hand for players 0 and 1.
    hands = [[], []];

    // Compute who wins this hand and update the points counter.
    // Returns 0 or 1 depending on which player won the hand.
    play(card0, card1) {
        const [pts, winner] = computeHand(card0, card1, this.trump_suit);
        // Update the points
        if (winner === 0) {
            this.points[0] += pts;
        } else {
            this.points[1] += pts;
        }
        return winner;
    }

    // Draws a card from the deck for player 0 or 1, and updates
    // the player's card `card` with the card drawn from deck.
    // Returns the card just drawn.
    drawCard(player, card) {
        if (this.deck.length === 0) {
            // We are in the final stage of the game.
            return undefined;
        }
        const next_card = this.deck.pop();
        const idx = state.hands.at(player).findIndex((c) => c === card);
        this.hands[player][idx] = next_card;
        return next_card;
    }

    // Returns a card randomly picked among the hand of `player`,
    // and remove it from `player`'s hand.
    getRandomCard(player) {
        const n_cards = this.hands.at(player).length;
        const idx = Math.floor(Math.random() * n_cards);
        const card = this.hands.at(player).at(idx);
        this.hands[player].splice(idx, 1);
        return card;
    }

    // Return true if we are in the final stage of the game
    // (no more draws from the deck).
    isEndGame() {
        return this.deck.length === 0;
    }
}

// Class to easily draw the playing board.
class Board {
    constructor() {
        this.cards_in_hand = document.querySelectorAll(".player_card");
        // First card played in this hand
        this.#cards_on_table[0] = document.querySelector("#fst");
        // Second card played in this hand
        this.#cards_on_table[1] = document.querySelector("#snd");
        // Slot to display points count.
        this.#points_counter[0] = document.querySelector("#points-p1");
        this.#points_counter[1] = document.querySelector("#points-p2");
        // Trump card (on table)
        this.trump_card = document.querySelector(".trump_card");
    }

    #cards_on_table = [];
    #points_counter = [];
    trump_card;

    // Returns the value of the last card played.
    getLastPlayed() {
        if (this.#cards_on_table.length === 0) {
            alert("Incorrect game state!");
        }
        return this.#cards_on_table.at(0).textContent;
    }

    // Player can be 0 for the human and 1 for the computer.
    // Turn can be 0 for the first to play the hand and 1
    // for the second player of the hand.
    play(player, turn, card) {
        if (player === 0) {
            this.#cards_on_table[turn].textContent = card.textContent;
            this.#cards_on_table[turn].style.visibility = "visible";
            card.style.visibility = "hidden";
        } else {
            this.#cards_on_table[turn].textContent = numberToCard(card);
            this.#cards_on_table[turn].style.visibility = "visible";
        }
    }

    // Removes the card from the table and updates
    // the cards in the player's hand.
    terminateHand(card, next_card, in_endgame) {
        this.#cards_on_table[0].style.visibility = "hidden";
        this.#cards_on_table[1].style.visibility = "hidden";
        if (next_card) {
            card.textContent = numberToCard(next_card);
            card.style.visibility = "visible";
        } else {
            // Do not update the cards in hand - it means we are
            // in the final stage of the game.
        }

        if (in_endgame) {
            // Hide the trump card from the board.
            this.trump_card.style.visibility = "hidden";
        }
    }

    // Updates the points counter.
    updatePoints(points) {
        this.#points_counter[0].textContent = points.at(0);
        this.#points_counter[1].textContent = points.at(1);
    }

}

</script>

</head>
<body>

<div id=playing_desk>

<div id=opponent_hand>
<button class=opponent_card></button>
<button class=opponent_card></button>
<button class=opponent_card></button>
</div>

<div id=table>
<button class=card_down id=fst></button>
<button class=card_down id=snd></button>
<button class=trump_card></button>
</div>

<div id=player_hand>
<button class=player_card></button>
<button class=player_card></button>
<button class=player_card></button>
</div>

</div>

<p id=points-count>Points: <span id=points-p1>0</span> <span id=points-p2>0</span></p>

<!-- Game logic starts here. -->
<script>
const board = new Board;
const state = new GameState;

// Draw the initial hand.
window.onload = (event) => {
    i = 0;
    board.cards_in_hand.forEach((card) => {
        card.textContent = numberToCard(state.hands[0].at(i));
        ++i;
    })
    // Paint last card.
    board.trump_card.textContent = numberToCard(state.deck.at(0));
};

// Takes as argument the card that was selected by the
// player.
async function playAsFirst(card) {
    const card_num = cardToNumber(card.textContent);
    board.play(0, 0, card);
    // Player 0 did just play a card. Now it's player 1's turn
    // to play a card, which will be chosen randomly.
    let card1_num = state.getRandomCard(1);
    await sleep(500);
    board.play(1, 1, card1_num);
    // Play the current hand
    const winner = state.play(card_num, card1_num);
    // Draw the card at the top of the deck.
    const next_card = state.drawCard(0, card_num);
    // Wait a little and redraw
    await sleep(1500);
    board.terminateHand(card, next_card, state.isEndGame());
    // Update points counter
    board.updatePoints(state.points);
    // Update player 1's cards.
    state.drawCard(1, card1_num);
    // If player 1 won, then it will play a random card
    // and wait for player 0's click.
    if (winner === 1) {
        // Player 1 plays a card chosen at random.
        card1_num = state.getRandomCard(1);
        await sleep(500);
        board.play(1, 0, card1_num);
        // Update player 1's cards.
        state.drawCard(1, card1_num);
        // Return, waiting for player 0's card.
    }
    // Update game state.
    state.won_last = winner === 0;
}


// Takes as argument the card that was selected by the
// player.
async function playAsSecond(card) {
    const card_num = cardToNumber(card.textContent);
    board.play(0, 1, card);
    await sleep(500);
    // Find what card was just played by player 1.
    card1_num = cardToNumber(board.getLastPlayed());
    // Play the current hand
    const winner = state.play(card1_num, card_num);
    // Draw the card at the top of the deck and use it to
    // replace the card just played.
    const next_card = state.drawCard(0, card_num);
    // Wait a little and redraw
    await sleep(1500);
    board.terminateHand(card, next_card, state.isEndGame());
    // Update points counter
    board.updatePoints(state.points);
    // If player 1 won, then it will play a random card
    // and wait for player 0's click.
    if (winner === 0) {
        // Player 1 plays a card chosen at random.
        card1_num = state.getRandomCard(1);
        await sleep(500);
        board.play(1, 0, card1_num);
        // Return, waiting for player 0's card.
    }
    // Update game state.
    state.won_last = winner === 1;
}

// Bind functions to card click events.
board.cards_in_hand.forEach((card) =>
    // Needs to be async to make the calls to sleep work.
    card.addEventListener("click", (event) => {
        if (state.hands[0].length === 0 && state.hands[1] === 0)
        {
            alert("Game is over.");
        } else {
            if (state.won_last) {
                playAsFirst(card);
            } else {
                playAsSecond(card);
            }
        }
    })
);
</script>

</body>
</html>
